:: first we import our /sur/ttt.hoon type definitions and expose them directly
::
/-  *ttt
:: our front-end takes in the bowl from our agent and also our agent's state
::
|=  [bol=bowl:gall gstate=appstate] ::   =page  playmap=playerinfo]
:: 5. we return an $octs, which is the encoded body of the HTTP response and its byte-length
::
|^  ^-  octs
:: 4. we convert the cord (atom string) to an octs
::
%-  as-octs:mimes:html
:: 3. we convert the tape (character list string) to a cord (atom string) for the octs conversion
::
%-  crip
:: 2. the XML data structure is serialized into a tape (character list string)
::
%-  en-xml:html
:: 1. we return a $manx, which is urbit's datatype to represent an XML structure
::
^-  manx
~&  "our gboard is:"  ~&  gstate
=/  clist=(list (list coord))  (make-keys rows.bsize.gstate cols.bsize.gstate)
=/  play-classes  (assign-classes status.gstate currplayer.gstate)

;html
  ;head
    ;title: tictactoe
    ;meta(charset "utf-8");
    ;style
      ;+  ;/  style
    ==  ::style
  ==  ::head
  ;body
    ;h1: Sample Tic-Tac-Toe Board:
    ;h2: ðŸ–™ Use console pokes to set moves.  Refresh the page to see the results.  See the structure file for more details. ðŸ–˜
    ;div.contain
      ;*  ?~  clist  !!
        %+  turn  clist
          |=  rclist=(list coord)
          ;div.board
            ;*
            ?~  rclist  !!
              %+  turn  rclist
              |=  rc=coord
                =/  value  (need (~(get by board.gstate) rc))
                =/  symbol  ?-  value
                        %o  "â­˜"
                        %e  "_"
                        %x  "â¨¯"
                      ==
                ;div.whitesquare: {symbol}
          == ::div outer
    ==  ::p
    ;br;
    ;div.ffcontain  
        ;div(id "p1", class p1.play-classes):  Player 1 - â¨¯
        ;div(id "p2", class p2.play-classes):  Player 2 - â­˜        
    ==
    ;br;
    ;form(method "post")
      ;div.refresh-container
        ;button(class "refresh-button", name "reset", value "5"): âŸ³
      ==
    ==
  == ::body
== ::html
:: A general reminder:  Use a mictar rune for each new %+ turn and sub-elements generated.
:: Using one mictar with multiple levels of loop and/or sub-elements leads to ruin.
:: When adding id and css attributes, its tag#css.class in that order!
++  assign-classes
  |=  [status=statussymbol player=playersymbol]
    ^-  [p1=tape p2=tape]
    ::  First check if the game is currently won, lost of drawn.
    ?-  status
        %p1win  [p1="player master" p2="player slave"]
        %p2win  [p1="player slave" p2="player master"]
        %draw  [p1="player limbo" p2="player limbo"]  
        %cont ::  If the game is ongoing, we assign classes based on the current player.
          ?:  =(player %p1x)
            [p1="player active" p2="player waiting"]
            [p1="player waiting" p2="player active"]
    ==
++  make-keys 
  |=  [rmax=@ud cmax=@ud]
    ^-  (list (list coord))
    =/  row  0
    =/   llcord  `(list (list coord))`~
    |-
      ^-  (list (list coord))
      ?:  (lth row rmax)
        %=  $
          llcord  (snoc llcord (get-row row cmax))
          row  +(row)
        ==
        llcord
++  get-row
  |=  [row=@ud cmax=@ud]
    ^-  (list coord)
      =/  col  0
      =/  result  `(list coord)`~
      |- 
      ^-  (list coord)
       ?:  (lth col cmax)
         %=  $
            result  (snoc result [row col])
            col  +(col)
          ==
          result
++  style
  ^~
  %-  trip
    ::Board CSS generated by chatGPT 3.5.
    '''
    body {background-color:black; color: orange;}
    h1 {font-size: 36pt; text-align: center;}
    h2 {font-size: 24pt; text-align: center;}
    div {font-size: 16pt;}

    .contain {
      position:relative;
      left:20%;
    }

    .ffcontain {
      width: 80%;
      margin: 0 auto; 
      display: flex;
    }

    .player {
      flex: 1; 
      text-align: center;
      padding: 10px;
      border: 1px solid #000; 
    }

    .active {
      background-color: orange;
      color: black;
    }

    .waiting {
      background-color: black;
      color: orange;
    }

    .master  {
      background-color: green;
      color: white;
    
    }

    .slave {
      background-color: red;
      color: white;
    }

    .limbo {
      background-color: gray;
      color: white;
    }

    .board {
      margin-top: 5px;
      display: grid;
      grid-template-columns: repeat(3, 500px);
      column-gap: 5px;

    }

    .square {
      width: 250px;
      height: 250px;
      background-color: orange;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: bold;
      color: black;
      cursor: pointer;
    }

    .blacksquare {
      width: 500px;
      height: 250px;
      background-color: black;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: bold;
      color: white;
      cursor: pointer;
    }

    .whitesquare {
      width: 500px;
      height: 250px;
      background-color: orange;
      color: blue;
      font-size: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
    }

    .refresh-container {
      width: 80%;
      margin: 0 auto; /* Center the outer container horizontally */
    }

    .refresh-button {
      width: 10%;
      margin: 0 auto; /* Center the inner container horizontally */
      text-align: center;
      padding: 10px;
      background-color: orange;
      color: black;
      cursor: pointer; /* Change cursor to pointer */
    }
    '''
--
